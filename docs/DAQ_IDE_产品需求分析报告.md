# DAQ IDE 产品需求梳理与分析报告

> **文档性质**: 产品需求分析 (PRD Pre-analysis)  
> **来源**: 基于《全版需求(DAQ).md》的产品经理视角梳理  
> **日期**: 2026-01-09

---

## 1. 产品愿景 (Product Vision)

> **"工业自动化领域的 'VSCode': 让 LabVIEW 的极简与 Qt 的强大在此交汇。"**

打造一个**双模式 (Dual-Mode)** 集成开发环境，旨在打破传统工业软件的壁垒。它将**运维效率**（无代码/低代码）与**工程精度**（专业代码）完美融合，实现数据采集系统的民主化开发。

## 2. 用户画像 (Target Personas)

明确服务的核心用户群体，是功能优先级排序的基础。

| 用户角色 | 典型职位 | 核心痛点 (Pain Points) | 价值主张 (Value Proposition) |
| :--- | :--- | :--- | :--- |
| **P1: 现场工程师** | DAQ 操作员、测试工程师 | 惧怕语法错误；需要**立即**看到数据波形；讨厌繁琐的编译器配置。 | **可视化拖拽 (LabVIEW模式)**: "连接传感器 A 到图表 B"，即连即用，零配置。 |
| **P2: 系统架构师** | C++ 开发者、系统集成商 | LabVIEW 太僵化且运行慢；需要自定义内存管理；离不开 Git 版本控制。 | **全代码控制 (Qt模式)**: 直接访问底层 C++/Python 逻辑，支持 CI/CD 流水线。 |
| **P3: 远程管理者** | 工厂经理、产线主管 | 需要在 iPad/手机上随时监控状态；懂业务但不写代码。 | **H5 仪表盘**: 基于 WebAssembly 技术，同一工程文件可一键发布为 Web 应用。 |

## 3. 需求架构五大支柱 (Strategic Pillars)

我们将 300 多条零散需求重组为 5 个核心战略支柱，以便于整体规划：

### 支柱 A: 双模式引擎 (Core Differentiator)
*这是产品的核心护城河 (USP)，也是技术风险最高的区域。*
*   **核心需求**: 实现可视化视图 (LabVIEW风格) 与 文本代码视图 (Qt/C++) 的无缝切换。
*   **产品策略**: 
    *   **单一事实来源 (Source of Truth)**: 必须定义 **DAQ-IR (中间表示层)**。
    *   **原则**: 视觉图生成 IR，代码编辑器编辑绑定在 IR 节点上的逻辑*钩子(Hooks)*。
    *   **约束**: 避免"魔法往返" (即避免尝试将任意 C++ 代码反编译为流程图)。需明确用户预期：**结构是可视化的，逻辑可以是代码的。**

### 支柱 B: 组件生态系统 (The "Lego Blocks")
系统的能力上限取决于组件库的丰富度。
*   **UI 组件**: 仪表盘、示波器 (高频动态刷新)、工业开关/旋钮。
*   **协议组件**: Modbus (RTU/TCP)、MQTT、EtherCAT (工业 4.0 关键)。
*   **算法组件**: FFT 变换、PID 控制、信号滤波。
*   **PM 建议**: 在 MVP (P2阶段) 聚焦于**"Top 10"**最高频使用的工业组件。与其做 100 个平庸的组件，不如做 10 个精品并提供强大的自定义能力。

### 支柱 C: 设备与数据底座 (The "Backend")
*   **硬件抽象层 (HAL)**: 用户无需关心底层是串口还是 TCP，统一接口调用。
*   **变量标签系统 (Tag System)**: 定义全局变量绑定 (如 `Device.Temp -> UI.Gauge`)。
*   **任务调度**: 系统的"节拍器" (定时循环、条件触发)。
*   **关键点**: 这是"运行时引擎" (Runtime Engine)。它必须极其健壮——即使 UI 崩溃卡死，后台的数据记录任务*绝对不能*停止。

### 支柱 D: 现代开发体验 (The "Velvet Rope")
*   **AI Copilot (MCP)**: "帮我配置一个温度传感器采集任务" -> 自动生成逻辑流。
*   **云原生技术**: 基于 VSCode 架构 + WebAssembly。
*   **PM 建议**: AI 是"惊喜型" (Delighter) 功能。它能极大提升产品溢价，但前提是核心引擎必须先做到 100% 稳定。

### 支柱 E: 部署与运维 (The "Last Mile")
*   **部署目标**: 桌面端 (Windows/Linux 占主流)、嵌入式终端 (无头模式)、Web 监控端。
*   **策略**: 优先攻克 **Windows 桌面端** (DAQ 市场存量最大)，其次是 Web 仪表盘。

## 4. 优先级矩阵 (MoSCoW Prioritization)

基于开发复杂度与业务价值的排序建议：

### 🔴 Must Have (MVP / Phase 2 - 必须有)
*   **架构**: VSCode 插件基础框架 + Python/C++ 后端进程通信 (IPC)。
*   **模式**: **LabVIEW 模式 (可视化流)** —— *这是验证核心价值的关键。*
*   **组件**: 基础串口通信 (Serial)、Modbus RTU、折线图 (Line Chart)、仪表盘、按钮。
*   **功能**: 工程保存/读取 (.daq)、简单的"开始/停止"逻辑。

### 🟡 Should Have (Phase 3 - 应该有)
*   **模式**: **QtCreator 模式 (代码视图)** —— *满足专业用户需求。*
*   **库**: SQLite 本地数据存储、报警触发器。
*   **组件**: TCP/IP 通信、MQTT 协议。
*   **功能**: 导出为独立 Exe 程序。

### 🟢 Could Have (Phase 4 - 可以有)
*   **AI**: MCP 智能助手功能。
*   **UI**: 3D 图表、自定义动效。
*   **部署**: WebAssembly 网页版发布 / 云端同步。

### ⚪ Won't Have (暂不考虑)
*   FPGA 硬件编译 (v1 版本复杂度过高)。
*   实时操作系统 (RTOS) 内核级定制。

## 5. 关键风险与应对 (Critical Risks)

| 风险点 | 影响 | 应对策略 |
| :--- | :--- | :--- |
| **"科学怪人"式 UI** | 应用体验像是在 VSCode 里硬塞网页，卡顿且割裂。 | **高性能渲染**: 针对高频波形 (100Hz+) 强制使用 **Canvas/WebGL** 技术，严禁使用 DOM 元素渲染大量数据。 |
| **同步地狱 (Sync Hell)** | 用户修改代码后，可视化流程图崩坏。 | **单向数据流** 或 **Code-Behind 模式**: 严格限制代码仅能修改节点的*内部逻辑*，而不能修改流程图的*拓扑结构*。 |
| **硬件兼容性黑洞** | "在我电脑上能跑，工厂电脑上就不行。" | **驱动沙盒化**: 构建健壮的驱动插件机制。将设备驱动与 IDE 主进程隔离，防止驱动崩溃导致 IDE 闪退。 |

## 6. 下一步执行建议 (Action Items)

1.  **冻结"数据模型"**: 在写任何 UI 代码前，先定义好描述"传感器"与"图表"之间连接关系的 JSON 结构 (DAQ-IR)。
2.  **原型验证"切换开关"**: 立即制作 Figma 原型，专门演示用户如何在"组件视图"和"代码视图"之间切换。这个交互体验是产品的生死线。
3.  **性能 POC**: 构建一个最小可行性验证 (Tiny POC)，在 VSCode WebView 中以 60FPS 渲染正弦波。如果这一步做不到流畅，"可视化 IDE" 的愿景就不成立。
