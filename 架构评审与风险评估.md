# DAQ IDE 架构评审与风险评估报告

> **评审角色**: 工业自动化架构师 + VSCode插件开发专家  
> **评审日期**: 2026-01-09  
> **评审对象**: DAQ集成开发环境需求文档 + 初版开发计划  
> **评审目标**: 识别技术风险、挑战架构可行性、提供落地方案

---

## 🔍 一、核心风险评估 (Critical Risk Assessment)

### 1.1 技术可行性红灯区 ⚠️

#### 🔴 RED FLAG #1: VSCode WebView 与 LabVIEW 实时数据流渲染的性能鸿沟

**问题描述**:
- LabVIEW 采用原生 DirectX/OpenGL 渲染数据流图，60fps+ 刷新率，支持数千节点实时连线
- VSCode WebView 本质是 Chromium iframe，受限于：
  - 主线程 JavaScript 单线程模型
  - DOM 操作开销（每次重绘触发 Layout + Paint）
  - 跨进程通信延迟（Extension Host ↔ WebView）
  - Canvas/SVG 在复杂图形下的性能瓶颈

**量化风险**:
- 当流程图节点数 > 100 时，拖拽延迟可能超过 100ms（用户可感知）
- 实时数据流动画（类似 LabVIEW 的数据流高亮）在 WebView 中需要每帧重绘，可能导致掉帧
- 大型工程（500+ 节点）加载时间可能超过 10 秒

**现有文档缺失**:
- 需求文档未量化"实时性"指标（刷新率、延迟阈值）
- 未说明是否支持硬件加速（WebGL、OffscreenCanvas）
- 未定义性能降级策略（如超过节点数时禁用动画）

**技术解决方案**:
```
方案A (推荐): WebGL + OffscreenCanvas
- 使用 PixiJS/Three.js 在 WebGL 中渲染流程图
- 数据流计算在 Web Worker 中执行
- 主线程仅负责事件响应
- 预期支持 500+ 节点 @ 60fps

方案B (折中): Canvas + Virtual Scrolling
- 仅渲染可视区域节点（虚拟滚动）
- 使用 Dirty Rectangle 技术减少重绘
- 预期支持 200 节点 @ 30fps

方案C (最保守): SVG + React Flow
- 适用于中小型项目（< 100 节点）
- 牺牲性能换取开发速度
- 风险: 大项目性能崩溃
```

**架构决策**: 
- 必须在 MVP 阶段实现 WebGL 方案原型验证
- 需要建立性能基准测试（Benchmark）：100/500/1000 节点场景
- 需要定义性能 SLA：节点数 N 与帧率 F 的函数关系

---

#### 🔴 RED FLAG #2: 双模式数据模型同步的原子性问题

**问题描述**:
需求文档 §2.1 承诺"两种模式可同时打开同一项目，进行协作开发"，但未说明：
- LabVIEW 模式的图形化节点如何映射到 QtCreator 模式的代码？
- 当用户在图形模式添加节点，代码模式是否实时生成代码？反之亦然？
- 如果两个模式同时编辑同一逻辑，如何处理冲突？

**具体冲突场景**:
```
场景1: 数据类型不匹配
- LabVIEW 模式: 用户拖拽一个"FFT分析"组件，输入是 double[]
- QtCreator 模式: 用户手写代码 fft_analysis(int[] data)
- 问题: 类型系统如何统一？谁覆盖谁？

场景2: 执行顺序歧义
- LabVIEW 模式: 数据流决定执行顺序（A → B → C）
- QtCreator 模式: 代码是顺序执行，但可能有异步调用
- 问题: 如何保证两种模式下的执行语义一致？

场景3: 实时协作冲突
- 用户A 在图形模式删除一个节点
- 用户B 在代码模式正在引用该节点对应的函数
- 问题: 类似 Git 冲突，但需要实时解决
```

**现有文档缺失**:
- 缺少"中间表示（IR）"层的设计
- 缺少冲突检测与解决策略（CRDTs？OT？）
- 缺少双向代码生成的细节（AST 解析、代码模板）

**技术解决方案**:
```
核心设计: 三层架构

┌─────────────────┐         ┌─────────────────┐
│ LabVIEW 模式    │         │ QtCreator 模式  │
│ (图形化)        │         │ (代码化)        │
└────────┬────────┘         └────────┬────────┘
         │                           │
         │   读/写                   │   读/写
         ▼                           ▼
    ┌────────────────────────────────────┐
    │   统一中间表示 (DAQ-IR)            │
    │   - 节点定义 (JSON Schema)         │
    │   - 数据流图 (DAG)                 │
    │   - 类型系统 (强类型)              │
    │   - 执行语义 (Execution Model)     │
    └────────────────────────────────────┘
         │
         │   持久化
         ▼
    ┌────────────────┐
    │  .daq 项目文件  │
    │  (JSON/Protobuf)│
    └────────────────┘

关键机制:
1. 所有编辑操作先写入 DAQ-IR，再同步到两种模式
2. 使用 Operational Transformation (OT) 处理并发编辑
3. 强制类型检查：图形化节点与代码函数签名必须匹配
4. 代码生成是单向的：IR → Code (只读)，禁止手动修改生成代码
```

**架构决策**:
- 必须定义 DAQ-IR 规范（类似 LLVM IR）
- 需要实现类型推导引擎（Type Inference Engine）
- 需要明确冲突解决策略，或限制"同时编辑"功能

---

#### 🔴 RED FLAG #3: 跨语言组件调用的运行时开销

**问题描述**:
需求文档 §3.3.4 支持 C/C++、Python、JavaScript、Blockly 多语言混合编程，但未说明：
- 运行时如何调用不同语言的组件？（FFI？IPC？）
- 性能开销是多少？（每次跨语言调用的延迟）
- 如何处理内存管理？（GC 语言 vs 手动管理）

**具体问题**:
```
场景: 高频数据采集
- 设备驱动: C++ 组件（1kHz 采样率）
- 信号处理: Python 组件（调用 NumPy）
- UI 更新: JavaScript 组件（WebView）

问题:
1. C++ → Python: 需要序列化/反序列化数据
2. Python → JS: 需要跨进程通信（可能 JSON 序列化）
3. 总延迟可能 > 10ms，无法满足 1kHz 实时性

工业场景要求:
- 数据采集周期 < 1ms (EtherCAT、CAN)
- 控制回路延迟 < 100μs (运动控制)
- 当前设计可能导致延迟 > 50ms
```

**现有文档缺失**:
- 缺少跨语言调用的性能基准
- 缺少零拷贝（Zero-Copy）方案
- 缺少实时性等级定义（硬实时 vs 软实时）

**技术解决方案**:
```
方案1: SharedArrayBuffer + WebAssembly (推荐)
- C++ 组件编译为 WASM
- 使用 SharedArrayBuffer 共享内存
- 避免序列化开销
- 预期延迟 < 1ms

方案2: Native Addon + Node-API
- Python/C++ 组件编译为 Node.js 原生插件
- 直接在同一进程内调用
- 需要处理 GIL（Python Global Interpreter Lock）
- 预期延迟 < 5ms

方案3: gRPC/ZeroMQ IPC (适用于隔离性要求高的场景)
- 每个组件运行在独立进程
- 通过高性能 IPC 通信
- 预期延迟 < 10ms
```

**架构决策**:
- 必须定义实时性等级（硬实时、软实时、非实时）
- 高频采集必须使用 C++/WASM + SharedArrayBuffer
- 需要建立跨语言调用的性能预算（Performance Budget）

---

#### 🔴 RED FLAG #4: LVGL 设计器集成的 API 边界模糊

**问题描述**:
需求明确"LVGL设计器之前已经独立开发成了一个插件"，但当前计划仅说"API对接"，未定义：
- 现有 LVGL 插件暴露哪些 API？
- 如果现有插件不支持某些功能（如主题同步、资源管理），如何处理？
- 如果现有插件使用不同的项目文件格式，如何兼容？

**潜在问题**:
```
场景1: 资源管理冲突
- DAQ IDE 的组件市场使用 npm/pip 管理依赖
- LVGL 插件可能使用自己的资源格式（如 .lvgl 格式）
- 如何统一？

场景2: 版本兼容性
- LVGL 插件支持 v8/v9
- DAQ IDE 未来可能需要支持 v10
- 谁负责升级？

场景3: UI 风格不一致
- DAQ IDE 使用双模式切换
- LVGL 插件可能有自己的 UI 风格
- 如何保持体验一致？
```

**架构决策**:
- 必须进行现有 LVGL 插件的 API 调研（Reverse Engineering）
- 定义最小 API 契约（Contract）：必须支持的接口
- 制定 Plan B：如果集成失败，是否需要 Fork 或重写？

---

### 1.2 逻辑一致性审查 🧩

#### 矛盾点 #1: "双模式共享同一套核心功能" vs "不同交互方式"

**需求文档 §2.1** 说：
> "两种模式共享同一套核心功能，但提供不同的交互方式和界面布局"

**问题**: 
- LabVIEW 模式隐藏代码细节，QtCreator 模式暴露代码
- 如果"共享同一套核心功能"，那 LabVIEW 模式能否访问底层代码？
- 如果不能，则不是"共享"，而是"映射"

**建议**: 
- 明确定义"核心功能"范围：是指运行时引擎？还是包括编辑器？
- 明确双模式的能力边界：LabVIEW 模式是否允许"降级"到代码模式？

---

#### 矛盾点 #2: "即插即用组件" vs "强类型系统"

**需求文档 §3.3** 强调组件"即插即用"，但同时要求"强类型"和"依赖注入"。

**问题**:
- 强类型系统需要编译时检查，但"即插即用"意味着运行时加载
- 如果组件在运行时加载，如何保证类型安全？
- 如果在编译时检查，则失去"即插即用"的灵活性

**建议**:
- 采用渐进式类型系统（类似 TypeScript）
- 运行时类型检查 + 静态类型提示
- 或明确区分"编译期组件"和"运行期组件"

---

## 🏗️ 二、关键架构决策建议 (Architecture Decisions)

### 2.1 核心技术栈选型

#### 决策 #1: 流程图编辑器 - 必须使用 Canvas/WebGL

**对比分析**:
| 方案 | 性能 | 开发成本 | 扩展性 | 推荐指数 |
|------|------|----------|--------|----------|
| **React Flow** | ⭐⭐ (SVG，节点数 < 100) | ⭐⭐⭐⭐⭐ (开箱即用) | ⭐⭐⭐ | ❌ 不适合工业级 |
| **G6/AntV** | ⭐⭐⭐ (Canvas，节点数 < 500) | ⭐⭐⭐⭐ (文档完善) | ⭐⭐⭐⭐ | ⚠️ 勉强可用 |
| **PixiJS + 自研** | ⭐⭐⭐⭐⭐ (WebGL，节点数 > 1000) | ⭐⭐ (需要自研) | ⭐⭐⭐⭐⭐ | ✅ 强烈推荐 |
| **原生 Canvas** | ⭐⭐⭐⭐ | ⭐ (极高成本) | ⭐⭐⭐⭐⭐ | ❌ 除非有充足人力 |

**最终决策**: 
```
第一阶段 (MVP): G6/AntV - 快速验证
第二阶段 (优化): 迁移到 PixiJS - 支持大规模工程

技术债务: 需要抽象图形引擎接口，便于后期替换
```

**代码示例**:
```typescript
// 抽象图形引擎接口
interface IGraphEngine {
  renderNode(node: Node): void;
  renderEdge(edge: Edge): void;
  onNodeDrag(callback: (node: Node) => void): void;
  setPerformanceMode(mode: 'high' | 'low'): void; // 性能降级
}

// G6 实现（MVP）
class G6GraphEngine implements IGraphEngine {
  // ...
}

// PixiJS 实现（优化阶段）
class PixiGraphEngine implements IGraphEngine {
  // ...
}
```

---

#### 决策 #2: 硬件抽象层 (HAL) 设计

**需求**: 统一管理 Python/C++ 驱动，支持串口/以太网/USB/CAN 等

**设计方案**:
```typescript
// 统一设备接口（TypeScript 定义）
interface IDevice {
  id: string;
  type: 'serial' | 'ethernet' | 'usb' | 'can';
  connect(): Promise<void>;
  disconnect(): Promise<void>;
  send(data: Uint8Array): Promise<void>;
  receive(): Promise<Uint8Array>;
  onData(callback: (data: Uint8Array) => void): void;
}

// 协议解析器接口
interface IProtocolParser {
  name: 'modbus' | 'mqtt' | 'scpi' | 'can';
  parse(raw: Uint8Array): ProtocolMessage;
  serialize(msg: ProtocolMessage): Uint8Array;
}

// 设备管理器（运行在 Extension Host）
class DeviceManager {
  private devices: Map<string, IDevice> = new Map();
  private parsers: Map<string, IProtocolParser> = new Map();

  // 设备发现（调用 Native Addon）
  async discoverDevices(): Promise<IDevice[]> {
    // 调用 C++ 原生模块扫描设备
    const nativeDevices = await nativeAddon.scanDevices();
    return nativeDevices.map(d => new DeviceProxy(d));
  }

  // 协议解析（支持插件扩展）
  registerParser(parser: IProtocolParser): void {
    this.parsers.set(parser.name, parser);
  }
}
```

**关键技术**:
- 使用 **Node-API (N-API)** 封装 C++ 驱动（跨 Node.js 版本兼容）
- 使用 **SharedArrayBuffer** 在 C++ 和 JS 之间零拷贝传输数据
- 使用 **Worker Threads** 隔离设备通信（避免阻塞主线程）

**性能保证**:
- 串口通信延迟 < 1ms
- 以太网通信延迟 < 5ms
- 支持高频采集（10kHz+）

---

#### 决策 #3: 数据流执行引擎设计

**需求**: 实现 LabVIEW 风格的数据流编程（Dataflow Programming）

**核心挑战**: 
- LabVIEW 的执行顺序由数据依赖决定，而非代码顺序
- 需要实现拓扑排序 + 并行调度

**设计方案**:
```typescript
// 数据流节点定义
interface DataFlowNode {
  id: string;
  type: string; // 'input' | 'process' | 'output'
  inputs: Port[];
  outputs: Port[];
  execute(inputs: Map<string, any>): Promise<Map<string, any>>;
}

// 数据流图
class DataFlowGraph {
  private nodes: Map<string, DataFlowNode> = new Map();
  private edges: Edge[] = [];

  // 拓扑排序（检测循环依赖）
  topologicalSort(): DataFlowNode[] {
    // Kahn's Algorithm
    // ...
  }

  // 执行引擎（支持并行）
  async execute(): Promise<void> {
    const sortedNodes = this.topologicalSort();
    const results = new Map<string, any>();

    for (const node of sortedNodes) {
      // 收集输入数据
      const inputs = new Map<string, any>();
      for (const input of node.inputs) {
        const sourceNode = input.connectedFrom;
        inputs.set(input.name, results.get(sourceNode.id));
      }

      // 并行执行（如果没有依赖）
      const outputs = await node.execute(inputs);
      results.set(node.id, outputs);
    }
  }
}
```

**高级特性**: 
- 支持条件分支（类似 LabVIEW 的 Case Structure）
- 支持循环（While Loop / For Loop）
- 支持子 VI（Sub-VI）调用

**性能优化**:
- 使用 **Web Worker Pool** 并行执行独立节点
- 使用 **Dirty Flag** 避免重复计算
- 使用 **Incremental Execution** 仅重新计算变化的节点

---

### 2.2 双模式同步机制

**最终设计**:
```
┌─────────────────────────────────────────────────────────┐
│                    DAQ-IR (JSON Schema)                 │
├─────────────────────────────────────────────────────────┤
│  {                                                      │
│    "nodes": [                                           │
│      { "id": "node1", "type": "ADC", "params": {...} }  │
│    ],                                                   │
│    "edges": [                                           │
│      { "from": "node1", "to": "node2", "port": "out1" } │
│    ],                                                   │
│    "typeSystem": {                                      │
│      "node1.out1": "double[]"                           │
│    }                                                    │
│  }                                                      │
└─────────────────────────────────────────────────────────┘
         ↓ 双向转换                      ↓ 单向生成
┌──────────────────┐            ┌──────────────────┐
│  LabVIEW 模式    │            │  QtCreator 模式  │
│  (图形化编辑)    │            │  (代码只读)      │
└──────────────────┘            └──────────────────┘
```

**同步规则**:
1. **LabVIEW → IR**: 用户拖拽节点 → 立即写入 IR → 触发代码生成
2. **QtCreator → IR**: 代码是**只读的**（自动生成），用户无法直接编辑
3. **高级用户**: 可以切换到"混合模式"，手动编辑生成代码（风险自负）

**冲突解决**: 
- 使用 **CRDTs (Conflict-free Replicated Data Types)** 处理并发编辑
- 或简化为**锁机制**：同一时间只允许一种模式编辑

---

## 🗓️ 三、MVP 阶段裁剪建议（20% 核心功能）

### 3.1 MVP 目标定义

**北极星指标**: 用户能够在 30 分钟内完成"采集-显示-控制"闭环

**具体场景**:
```
用户故事: 
作为一名电气工程师，我想用 DAQ IDE 快速搭建一个温度监控系统：
1. 连接 Modbus RTU 温度传感器（串口）
2. 实时显示温度曲线（折线图）
3. 当温度 > 80℃ 时，控制风扇启动（GPIO 输出）
4. 生成 PDF 测试报告

时间预算:
- 设备连接: 5 分钟
- 拖拽流程图: 10 分钟
- UI 设计: 10 分钟
- 调试运行: 5 分钟
```

---

### 3.2 MVP 功能清单（20% 核心）

#### ✅ 必须保留

| 模块 | 功能 | 原因 |
|------|------|------|
| **基础架构** | VSCode 插件框架 | 基础依赖 |
| **基础架构** | 单一模式（仅 LabVIEW 模式） | 降低复杂度，双模式推迟到 V2 |
| **项目管理** | 创建空白项目 | 最小可用 |
| **设备管理** | 串口设备连接 | 最常用接口 |
| **设备管理** | Modbus RTU 协议 | 工业标准协议 |
| **流程图设计器** | 基础节点拖拽 + 连线 | 核心交互 |
| **流程图设计器** | 数据流执行引擎（单线程） | 核心能力 |
| **组件库** | 10 个基础组件（ADC、DAC、PID、图表等） | 够用即可 |
| **H5 设计器** | 基础控件（按钮、输入框、折线图） | 最小 UI |
| **数据处理** | SQLite 本地存储 | 最简单方案 |
| **部署** | 本地运行（无需嵌入式部署） | 降低难度 |

#### ❌ MVP 阶段砍掉

| 模块 | 功能 | 推迟原因 |
|------|------|----------|
| **双模式** | QtCreator 模式 | 复杂度高，V2 再做 |
| **设备管理** | 以太网/USB/蓝牙 | 串口够用，其他推迟 |
| **协议** | MQTT/CAN/EtherCAT/OPC UA | 工业高级协议，V2 再做 |
| **LVGL 设计器** | 嵌入式 UI | 与 MVP 场景无关 |
| **Blockly 设计器** | 积木编程 | LabVIEW 模式已足够 |
| **算法组件库** | FFT/滤波/高级算法 | 非必需，用户可自定义 |
| **AI 功能** | 所有 AI 功能 | 锦上添花，V3 再做 |
| **组件市场** | 云端组件库 | 本地库即可 |
| **国际化** | 多语言支持 | 仅支持中文 |
| **远程调试** | JTAG/OTA | 与 MVP 场景无关 |
| **CI/CD** | 自动化部署 | 手动部署即可 |

---

### 3.3 MVP 开发计划（3 个月）

#### 第 1 个月: 基础框架 + 设备管理
- Week 1-2: VSCode 插件框架 + WebView 通信
- Week 3: 串口设备发现与连接（使用 serialport npm 包）
- Week 4: Modbus RTU 协议解析器（使用 modbus-serial）

#### 第 2 个月: 流程图 + 组件库
- Week 5-6: 流程图编辑器（使用 G6）
- Week 7: 数据流执行引擎（单线程版本）
- Week 8: 10 个基础组件开发

#### 第 3 个月: UI 设计 + 集成测试
- Week 9: H5 设计器（使用 React + Ant Design）
- Week 10: 数据存储（SQLite）
- Week 11: 端到端集成测试
- Week 12: Bug 修复 + 性能优化

**交付标准**: 
- 能够运行"温度监控"示例项目
- 性能: 100 节点流程图 @ 30fps
- 文档: 快速入门教程

---

## 💡 四、被忽略的隐性需求（工业级必备）

### 4.1 高可用性需求

#### 🛡️ 看门狗机制 (Watchdog)

**工业场景**: 
- DAQ 系统可能运行在无人值守环境（如远程油井、变电站）
- 如果系统崩溃，可能导致设备损坏或安全事故

**需求**: 
- 系统必须具备自动重启能力
- 检测死锁、内存泄漏、进程僵死

**实现方案**:
```typescript
// 主进程看门狗
class Watchdog {
  private lastHeartbeat: number = Date.now();
  private checkInterval: NodeJS.Timeout;

  start() {
    this.checkInterval = setInterval(() => {
      const now = Date.now();
      if (now - this.lastHeartbeat > 10000) { // 10 秒无心跳
        console.error('System deadlock detected! Restarting...');
        process.exit(1); // 让外部守护进程重启
      }
    }, 1000);
  }

  heartbeat() {
    this.lastHeartbeat = Date.now();
  }
}

// 外部守护进程（使用 PM2 或 systemd）
// pm2 start daq-ide --name "DAQ-IDE" --restart-delay=3000
```

**需求文档缺失**: 完全未提及

---

#### 🔄 崩溃恢复 (Crash Recovery)

**工业场景**:
- 用户编辑了 2 小时的流程图，突然断电
- 设备采集了 10GB 数据，系统崩溃

**需求**:
- 自动保存未提交的编辑（类似 Word 自动保存）
- 数据采集必须持久化到磁盘（Write-Ahead Log）

**实现方案**:
```typescript
// 自动保存机制
class AutoSave {
  private saveInterval: NodeJS.Timeout;

  start(project: Project) {
    this.saveInterval = setInterval(() => {
      const snapshot = project.serialize();
      fs.writeFileSync('.daq-autosave.json', JSON.stringify(snapshot));
    }, 30000); // 每 30 秒保存一次
  }

  recover(): Project | null {
    if (fs.existsSync('.daq-autosave.json')) {
      const data = fs.readFileSync('.daq-autosave.json', 'utf-8');
      return Project.deserialize(JSON.parse(data));
    }
    return null;
  }
}
```

**需求文档缺失**: 仅提及"数据备份"，未说明崩溃恢复

---

### 4.2 安全性需求

#### 🔐 许可证加密管理

**工业场景**:
- DAQ IDE 作为商业软件，需要防止盗版
- 客户可能购买不同级别的许可证（标准版、专业版、企业版）

**需求**:
- 软件激活机制（在线/离线）
- 功能模块授权（如高级算法库需要额外购买）
- 防篡改（代码签名）

**实现方案**:
```typescript
// 许可证验证（使用 RSA 公钥加密）
class LicenseManager {
  private publicKey: string = '-----BEGIN PUBLIC KEY-----...';

  validate(license: string): boolean {
    try {
      const decoded = jwt.verify(license, this.publicKey, { algorithms: ['RS256'] });
      return decoded.expiry > Date.now();
    } catch (e) {
      return false;
    }
  }

  checkFeature(feature: string): boolean {
    const license = this.getCurrentLicense();
    return license.features.includes(feature);
  }
}

// 使用示例
if (!licenseManager.checkFeature('advanced-algorithms')) {
  throw new Error('此功能需要专业版许可证');
}
```

**需求文档缺失**: 完全未提及（商业软件的致命缺失）

---

#### 🔒 数据加密传输

**工业场景**:
- 设备通过网络传输敏感数据（如生产配方、工艺参数）
- 需要防止数据被窃听或篡改

**需求**:
- 支持 TLS/SSL 加密通信
- 支持设备身份验证（证书、Token）

**实现方案**:
```typescript
// Modbus TCP 加密通信
import tls from 'tls';

class SecureModbusClient {
  private client: tls.TLSSocket;

  connect(host: string, port: number, cert: string) {
    this.client = tls.connect({
      host,
      port,
      ca: [cert], // CA 证书
      rejectUnauthorized: true, // 验证服务器证书
    });
  }
}
```

**需求文档缺失**: 仅提及"安全传输"，未明确协议

---

### 4.3 工业现场特殊需求

#### ⚡ 极端环境适配

**工业场景**:
- 高温车间（50℃+）、粉尘环境、强电磁干扰
- 设备可能运行在无风扇工控机上

**需求**:
- 低功耗模式（减少 CPU 占用）
- 容错机制（处理丢包、数据错误）

**实现方案**:
```typescript
// 低功耗模式
class PowerManager {
  enableLowPowerMode() {
    // 降低刷新率
    this.setRefreshRate(10); // 从 60fps 降到 10fps
    // 禁用动画
    this.disableAnimations();
    // 减少日志
    this.setLogLevel('error');
  }
}
```

---

#### 📊 审计日志 (Audit Log)

**工业场景**:
- 医药、食品行业需要符合 FDA 21 CFR Part 11 法规
- 必须记录所有操作（谁、何时、做了什么）

**需求**:
- 不可篡改的日志（使用区块链或数字签名）
- 日志包含：用户、时间戳、操作类型、参数

**实现方案**:
```typescript
// 审计日志
class AuditLogger {
  log(user: string, action: string, params: any) {
    const entry = {
      user,
      timestamp: new Date().toISOString(),
      action,
      params,
      hash: this.calculateHash(user, action, params),
    };
    fs.appendFileSync('audit.log', JSON.stringify(entry) + '\n');
  }

  private calculateHash(...args: any[]): string {
    return crypto.createHash('sha256').update(JSON.stringify(args)).digest('hex');
  }
}
```

**需求文档缺失**: 完全未提及（监管行业的致命缺失）

---

## 📌 五、架构决策记录 (ADR)

### ADR-001: 流程图引擎选择

**状态**: 已批准  
**决策**: MVP 使用 G6，V2 迁移到 PixiJS  
**理由**: 
- G6 开发速度快，适合快速验证
- PixiJS 性能更好，适合大规模工程
- 抽象接口便于后期替换

**后果**:
- 技术债务：需要在 V2 进行引擎迁移
- 风险：如果 G6 性能不足，可能导致 MVP 演示失败

---

### ADR-002: 双模式同步机制

**状态**: 待定  
**决策**: MVP 阶段仅支持 LabVIEW 模式，QtCreator 模式推迟到 V2  
**理由**: 
- 双模式同步极其复杂，风险高
- MVP 阶段聚焦核心功能

**备选方案**:
- 方案 A: 代码只读（自动生成）
- 方案 B: 完全独立（两种模式不同步）
- 方案 C: 使用中间表示（DAQ-IR）

**后续行动**: 在 V2 阶段进行技术原型验证

---

### ADR-003: LVGL 插件集成

**状态**: 高风险  
**决策**: MVP 阶段不集成 LVGL，专注于 H5 设计器  
**理由**: 
- 现有 LVGL 插件的 API 未知，集成风险高
- H5 设计器已能满足 MVP 需求

**后续行动**: 
- 进行 LVGL 插件 API 调研
- 评估集成成本
- 如果成本过高，考虑 Fork 或重写

---

## 🚨 六、关键风险与缓解措施

| 风险 | 影响 | 概率 | 缓解措施 |
|------|------|------|----------|
| VSCode WebView 性能不足 | 高 | 中 | 提前进行性能基准测试，准备 WebGL 方案 |
| 双模式同步逻辑错误 | 高 | 高 | MVP 阶段仅支持单模式，降低复杂度 |
| 跨语言调用延迟过高 | 中 | 中 | 使用 SharedArrayBuffer，避免序列化 |
| LVGL 插件集成失败 | 中 | 高 | MVP 阶段不集成，使用 H5 设计器替代 |
| 工业级需求遗漏 | 高 | 高 | 补充看门狗、崩溃恢复、许可证管理 |
| 开发周期延误 | 中 | 中 | 严格控制 MVP 范围，砍掉非核心功能 |

---

## 📝 七、总结与行动建议

### 7.1 当前开发计划的主要问题

1. **缺少技术风险分析**: 未评估 VSCode WebView 性能限制
2. **缺少架构深度设计**: 未定义数据流执行引擎、HAL 接口
3. **MVP 范围过大**: 包含 80% 功能，而非 20%
4. **缺少工业级隐性需求**: 看门狗、崩溃恢复、许可证、审计日志

### 7.2 立即行动项

#### 🔴 高优先级（本周完成）
1. 进行 WebView 性能基准测试（100/500/1000 节点）
2. 定义 DAQ-IR 中间表示规范（JSON Schema）
3. 调研现有 LVGL 插件的 API
4. 重新定义 MVP 范围（仅保留 20% 核心功能）

#### 🟡 中优先级（本月完成）
5. 设计硬件抽象层（HAL）接口
6. 实现数据流执行引擎原型
7. 设计许可证加密方案
8. 补充工业级隐性需求到需求文档

#### 🟢 低优先级（下月完成）
9. 制定双模式同步技术方案（ADR）
10. 建立性能监控体系

---

**评审结论**: 
- 当前需求文档过于理想化，缺少技术可行性分析
- 当前开发计划缺少架构深度设计和风险控制
- 建议立即进行技术原型验证，避免后期推倒重来

**签名**: 架构评审专家  
**日期**: 2026-01-09
